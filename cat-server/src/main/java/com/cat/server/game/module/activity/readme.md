1. 实现多时间段的时间点
2. 实现单时间段循环的时间点

注意
ActivityService和PlayerActivityService区别
ActivityService作为活动service, 活动是公共模块,不会单独处理任何玩家相关的逻,
维护一份纯活动相关的逻辑
PlayerActivityService 处理玩家消息请求通知,处理玩家相关的业务逻辑与事件监听


问题
玩家活动数据存放到活动模块,还是玩家个人模块?
若放到活动模块优点
1: 方便, 因为玩家数据再活动初始化时,加载至了内存, 所以活动结束后, 直接从内存中拿到所有参与过的玩家数据, 然后结算发放奖励
2: 玩家生命周期直接跟活动生命周期挂钩, 可以根据活动的生命周期初始化, 销毁玩家数据.
3: 对于玩家数据的生成, 销毁工作变得尤其简单, 活动未开启时不会初始化此活动的玩家数据, 结束后根据缓存的玩家ids进行邮件处理, 以及善后工作

缺点
1. 存储上所有的玩家数据集中在一个字段, 空间占用比较大, 且针对活动玩家的数据查询不太友好.
2. 玩家个人模块的数据, 不符合现有架构模型, 活动模块的结构有所变动, Activity中的customData中就缓存玩家的活动数据, 活动数据中会定义任务数据,大致是这样结构,层级调用较深
ActivityManager->Activity->ActivityData->ActivitPlayerData->MissionTypeData->Mission


玩家数据放到个人模块优点
1. 单字段/列存储占用空间不大, 分散到整个表, 查询方便
2. 符合现有架构模型, 代码生成即用. 层级调用较浅, 根据需要显示调用活动玩家数据

缺点
1. 处理状态切换时, 比较麻烦, 可能需要事件通知在线玩家, 然后不在线玩家登录时处理 
2. 不太符活动的生命周期转换, 活动结束后只能处理在线玩家数据的活动结算, 离线玩家只能放在登录时处理
3. 如果活动数据存储一份参与玩家列表, 则需要同时维护两份数据, 一份活动内的玩家缓存列表, 一份玩家数据
4. 活动相当于常驻模块, 玩家登录后每个方法需要根据活动状态进行过滤, 如果状态为未开启, 则代码跳出不继续执行
5. 旧活动配置如果发生改变, 会影响长期未登录玩家登录时的活动结算.
 
 决定两种方式都做一遍, 目前先用数据存储到玩家模块处理一下
玩家活动数据个人模块
1. learncomunity 先存储到了个人模块, 准备改成存储到活动模块实现


20220111
在完善活动过程中, 逐渐找到了一种更好的方式, 融合了以上两种方法的优点, 又完美避开所述缺点
大致思路, 活动数据跟玩家活动数据依旧分离, 活动模块获取数据时, 个人模块的生命周期挂在活动商
ActivityManager->ActivityDomain->ActivityType->





